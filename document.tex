%%%% Generic manuscript mode, required for submission
%%%% and peer review
\documentclass[manuscript,screen,review,sigplan]{acmart}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{XXX}
\copyrightyear{XXXX}
\acmYear{XXXX}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[ICFP '22]{International Conference on Functional Programming}{Sept 11--16,
  2022}{Ljubljana, Slovenia}
%
%  Uncomment \acmBooktitle if th title of the proceedings is different
%  from ``Proceedings of ...''!
%
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
% June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{listings}
\usepackage{amsthm}

\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\newtheorem{theorem}{Theorem}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Equationally Correct Semantics (Extended Abstract)}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Cameron Wong}
\affiliation{%
  \institution{Jane Street/Harvard University}
  \country{USA}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Wong}

\newcommand{\N}{\mathbb{N}}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10002990</concept_id>
<concept_desc>Theory of computation~Logic and verification</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Logic and verification}
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{dependent types, soundness, language semantics}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

When developing a new programming language, the most important foundational
consideration is ensuring that it is \emph{type safe}. Without this crucial
property, it is difficult to reason abstractly about programs written in such
a language, often requiring extra specification, or whole-program reasoning to
ensure that a seemingly type-correct program behaves as desired. Despite this
importance, the process of producing a soundness proof is rarely interesting in
and of itself, with the proof(s) frequently reduced to a sketch stating only
what to induct on.

%It can be far more illustrative when a soundness proof \emph{fails}, as this
%can highlight inherent problems with the core language semantics and suggest
%way those problems can be fixed. But how can this be, when the finished proofs
%are so simple as to be left as exercises to the reader?

As these proofs are so simple, a natural question is whether these proofs can
be automatically generated. While there is a wealth of recent work on
\emph{implementing} programming languages in an automatically correct way
(Rouvoet \cite{rouvoet:2021}, Pardo et al \cite{pardoetal:2018}, among many
others), we were unable to find any research on automatically ensuring that the
language semantics \emph{themselves} are sound.

We adapt the approach pioneered by Bahr and Hutton \cite{bahr:2015} for
computing compilers to instead compute the runtime semantics of a type system
to automatically satisfy progress and preservation.
In the rest of this document, we first describe how the classic formulation of
type soundness can be phrased as an equation, then use that equation to
derive a small-step operational semantics for a simple expression language.
Following the example of Pickard and Hutton \cite{pickard:2021}, all our
programs and calculations are done in Agda, as the additional precision of
dependent types is necessary to avoid otherwise-troublesome partiality issues.

\section{Type Safety as an Equation}

To reason equationally, we must first find a suitable equation to reason about.

Proving type safety classically requires proving the twin theorems of
progress and preservation \cite{harper:pfpl}. Colloquially, progress states
that ``well-typed programs do not get stuck'', and preservation states that
``a program has the same type after each evaluation step''. The latter seems
promising for an equational approach, as it is a statement \emph{equating} two
things -- namely, the type of an expression before and after being stepped.

We specify the target language by converting its typing judgment $\Gamma
\vdash e : \tau$ into an Agda function

\begin{equation}
  \texttt{typeof} : \texttt{Exp} \rightarrow \texttt{Maybe Type}
\end{equation}

with the property $\texttt{typeof}\ e = \tau$ iff $\emptyset \vdash e : \tau$.

We next amend the type of \texttt{step} to take a witness that its argument
is well-typed, which will be useful later:

\begin{equation}
  \texttt{step} : (e: \texttt{Exp}) \rightarrow (\emptyset \vdash e : \tau)
    \rightarrow \texttt{Exp}
\end{equation}

Finally, we must address values, which cannot be stepped. Typically, this is
expressed by having the \texttt{step} function return a partial value akin to
\texttt{Maybe}. However, this representation is extremely unwieldy to work with
in an equation, so we instead parameterize the \texttt{Exp} datatype by whether
it can be stepped.

\begin{lstlisting}
  data Steppable : Set where
    Value: Steppable
    Steps: Steppable

  data Exp : Steppable $\rightarrow$ Set where
    ...

  step : ($e:$ Exp Steps) $\rightarrow$ $(\emptyset \vdash e : \tau) \rightarrow \exists S . \texttt{Exp}\ S$
\end{lstlisting}

Note that \texttt{step} now returns an existential \texttt{Exp }$S$, as we
cannot know whether the result can be evaluated further.

Agda enforces that functions are total, so any well-typed implementation of the
\texttt{step} function is a proof of the progress theorem. All the pieces are
in place, then, to relate progress (\texttt{step}) to the typing judgment
(\texttt{typeof}) via the \emph{preservation equation}:

\begin{equation}
  \texttt{typeof}\ e = \texttt{typeof}\ (\texttt{step e p})
\end{equation}

where $e : \texttt{Exp CanStep}$ and $p : (\emptyset \vdash e : \tau)$ for some
$\tau : \texttt{Type}$.

\section{The Derivation}

\subsection{Target Language}

Our target language for this demonstration is a simple, typed expression
language as follows:

\begin{lstlisting}
  data Exp : Steppable $\rightarrow$ Set where
    boolVal : Bool $\rightarrow$ Exp Value
    intVal : $\N \rightarrow$ Exp Value
    add : Exp $S \rightarrow$ Exp Steps
    if : Exp $S_n \rightarrow$ Exp $S_1 \rightarrow$ Exp $S_2 \rightarrow$ Exp Steps
\end{lstlisting}

where $\N$ represents Agda's usual type of natural numbers.

We don't use the usual dependently-typed trick of parameterizing
\texttt{Exp} with its type, as it would trivialize the \texttt{typeof}
function, breaking the trick.

Speaking of, we define \texttt{typeof} as follows:\footnote{The actual
implementation in Agda is somewhat more complex, and is simplified for
presentation. Agda does not support Haskell-style \texttt{case} expressions,
nor can it, in general, decide equality or inequality of \texttt{Set}s.
Instead, we use the usual \texttt{fold} operator over the \texttt{Maybe}
type and use a regular Agda variant to represent $\N$ and \texttt{Bool}.}

\begin{lstlisting}
  typeof (boolVal \_) = Bool
  typeof (intVal \_) = $\N$
  typeof (add $e_1$ $e_2$) =
    case (typeof $e_1$, typeof $e_2$)
      of (Just $\N$, Just $\N$) -> Just $\N$
       | \_ -> Nothing
  typeof (if $e$ $e_1$ $e_2$) =
    case (typeof $e$, typeof $e_1$, typeof $e_2$)
      of (Just Bool, Just $\tau_1$, Just $\tau_2$) ->
           if $\tau_1 = \tau_2$ then Just $\tau_1$ else Nothing
       | \_ -> Nothing
\end{lstlisting}

\bibliographystyle{acm}
\bibliography{refs}

\end{document}
%%
