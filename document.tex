%%%% Generic manuscript mode, required for submission
%%%% and peer review
\documentclass[manuscript,screen,review,sigplan]{acmart}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{XXX}
\copyrightyear{XXXX}
\acmYear{XXXX}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[ICFP '22]{International Conference on Functional Programming}{Sept 11--16,
  2022}{Ljubljana, Slovenia}
%
%  Uncomment \acmBooktitle if th title of the proceedings is different
%  from ``Proceedings of ...''!
%
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
% June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{listings}
\usepackage{amsthm}

\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\newtheorem{theorem}{Theorem}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Equationally Correct Semantics (Extended Abstract)}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Cameron Wong}
\affiliation{%
  \institution{Jane Street/Harvard University}
  \country{USA}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Wong}

\newcommand{\N}{\mathbb{N}}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10002990</concept_id>
<concept_desc>Theory of computation~Logic and verification</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Logic and verification}
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{dependent types, soundness, language semantics}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

%When developing a new programming language, the most important foundational
%consideration is ensuring that it is \emph{type safe}. Without this crucial
%property, it is difficult to reason abstractly about programs written in such
%a language, often requiring extra specification, or whole-program reasoning to
%ensure that a seemingly type-correct program behaves as desired. Despite this
%importance, the process of producing a soundness proof is rarely interesting in
%and of itself, with the proof(s) frequently reduced to a sketch stating only
%what to induct on.

%It can be far more illustrative when a soundness proof \emph{fails}, as this
%can highlight inherent problems with the core language semantics and suggest
%way those problems can be fixed. But how can this be, when the finished proofs
%are so simple as to be left as exercises to the reader?

%As these proofs are so simple, a natural question is whether these proofs can
%be automatically generated. While there is a wealth of recent work on
%\emph{implementing} programming languages in an automatically correct way
%(Rouvoet \cite{rouvoet:2021}, Pardo et al \cite{pardoetal:2018}, among many
%others), we were unable to find any research on automatically ensuring that the
%language semantics \emph{themselves} are sound.

We adapt the approach pioneered by Bahr and Hutton \cite{bahr:2015} for
computing compilers to instead compute the runtime semantics of a type system
to automatically satisfy progress and preservation.
In this document, we first describe how the classic formulation of
type soundness can be phrased as an equation, then use that equation to
derive a small-step operational semantics for a simple expression language.
Following the example of Pickard and Hutton \cite{pickard:2021}, all our
programs and calculations are done in Agda, as the additional precision of
dependent types is necessary to avoid otherwise-troublesome partiality issues.

\section{Type Safety as an Equation}

To reason equationally, we must first find a suitable equation to reason about.

Proving type safety classically requires proving the twin theorems of
progress and preservation \cite{harper:pfpl}. Colloquially, progress states
that ``well-typed programs do not get stuck'', and preservation states that
``a program has the same type after each evaluation step''. The latter seems
promising for an equational approach, as it is a statement \emph{equating} two
things -- namely, the type of an expression before and after being stepped.

We specify the target language by converting its typing judgment $\Gamma
\vdash e : \tau$ into an Agda function

\begin{equation*}
  \texttt{typeof} : \texttt{Exp} \rightarrow \texttt{Maybe Type}
\end{equation*}

with the property $\texttt{typeof}\ e = \tau$ iff $\emptyset \vdash e : \tau$.

Next, we must address values, which cannot be stepped. Typically, this is
expressed by having the \texttt{step} function return a partial value akin to
\texttt{Maybe}. However, this representation is extremely unwieldy to work with
in an equation, so we instead parameterize the \texttt{Exp} datatype by whether
it can be stepped.

\begin{lstlisting}
  data Steppable : Set where
    Value: Steppable
    Steps: Steppable

  data Exp : Steppable $\rightarrow$ Set where
    ...

  step : ($e:$ Exp Steps) $\rightarrow \exists S . \texttt{Exp}\ S$
\end{lstlisting}

Notice that \texttt{step} now returns an existential \texttt{Exp }$S$, as we
cannot know whether the result can be evaluated further.

There is a further issue of attempting to step ill-typed programs. In the
implementation, this is resolved by further amending \texttt{step} to also take
a proof that its argument is well-typed. As Agda enforces that functions are
total, such a function actually serves as a proof of the progress theorem.
This obfuscates the calculation, however, so we will elide it and assume that
the expression being stepped is, in fact, well-formed.

All the pieces are
in place, then, to relate progress (\texttt{step}) to the typing judgment
(\texttt{typeof}) via the \emph{preservation equation}:

\begin{equation}\label{eq:preservation}
  \texttt{typeof}\ e = \texttt{typeof}\ (\texttt{step e})
\end{equation}

where $e : \texttt{Exp CanStep}$.

\section{The Derivation}

\subsection{Target Language}

Our target language for this demonstration is a simple, typed expression
language as follows:

\begin{lstlisting}
  data Exp : Steppable $\rightarrow$ Set where
    boolVal : Bool $\rightarrow$ Exp Value
    intVal : $\N \rightarrow$ Exp Value
    add : Exp $S \rightarrow$ Exp Steps
    if_ : Exp $S_n \rightarrow$ Exp $S_1 \rightarrow$ Exp $S_2 \rightarrow$ Exp Steps
\end{lstlisting}

with the following typing rules (in Agda):

where $\N$ represents Agda's usual type of natural numbers.

We don't use the usual dependently-typed trick of parameterizing
\texttt{Exp} with its type, as it would trivialize the \texttt{typeof}
function, breaking the trick.

Speaking of, the implementation of \texttt{typeof}:\footnote{The actual
implementation in Agda is somewhat more complex, and is simplified for
presentation. Agda does not support Haskell-style \texttt{case} expressions,
nor can it, in general, decide equality or inequality of \texttt{Set}s.
Instead, we use the usual \texttt{fold} operator over the \texttt{Maybe}
type and use a regular Agda variant to represent $\N$ and \texttt{Bool}.}

\begin{lstlisting}
  typeof (boolVal _) = Bool
  typeof (intVal _) = $\N$
  typeof (add $e_1$ $e_2$) =
    case (typeof $e_1$, typeof $e_2$)
      of (Just $\N$, Just $\N$) -> Just $\N$
       | _ -> Nothing
  typeof (if_ $e$ $e_1$ $e_2$) =
    case (typeof $e$, typeof $e_1$, typeof $e_2$)
      of (Just Bool, Just $\tau_1$, Just $\tau_2$) ->
           if_ $\tau_1 = \tau_2$ then Just $\tau_1$ else Nothing
       | _ -> Nothing
\end{lstlisting}

We are ready to proceed. Our goal is to define the function \texttt{step}
satisfying equation \ref{eq:preservation}. As per Bahr and Hutton
\cite{bahr:2015}, we will proceed by structural induction on $e$, evaluating
the left hand side of equation \ref{eq:preservation} and seek to transform it
into an expression of the form $\texttt{typeof}\ c$, then take $\texttt{step e}
= c$ as a definition for that case of \texttt{step}.

\subsection{Semantics Calculation}

For brevity, we only show the two most demonstrative cases.

\textbf{Case:} $e = \texttt{add}\ e_1\ e_2$, where $e_1 : \texttt{Exp CanStep}$

We begin by applying the definition of \texttt{typeof}:

\begin{lstlisting}
  typeof (add $e_1$ $e_2$)
    = $\langle\textsf{definition of \texttt{typeof}}\rangle$
  case (typeof $e_1$, typeof $e_2$) ...
\end{lstlisting}

We are immediately stuck, as we cannot expand $\texttt{typeof}\ e_1$ any
further. To proceed, we have no choice but to cite the inductive hypothesis:

\begin{lstlisting}
  case (typeof $e_1$, typeof $e_2$) ...
    = $\langle\textsf{inductive hypothesis on \texttt{typeof} }e_1\rangle$
  case (typeof (step $e_1$), typeof $e_2$) ...
\end{lstlisting}

We finally apply the definition of \texttt{typeof} in reverse:

\begin{lstlisting}
  case (typeof (step $e_1$), typeof $e_2$) ...
    = $\langle\textsf{definition of \texttt{typeof}}\rangle$
  typeof (add (step $e_1$) $e_2$)
\end{lstlisting}

This is now of the form $\texttt{typeof} (\texttt{add}\ e_1\ e_2) = \texttt{typeof}\ c$,
namely, $c = \texttt{add}\ (\texttt{step}\ e_1)\ e_2$. We wrap up by defining
\texttt{step} for this case:

\begin{lstlisting}
  step (add $e_1$ $e_2$) = add (step $e_1$) $e_2$
\end{lstlisting}

We note in passing that this construction forces a ``left-first'' evaluation
strategy. If both $e_1$ and $e_2$ can be stepped, we have the choice of
invoking the inductive hypothesis on $e_1$, $e_2$ or both, corresponding to
left-first, right-first or parallel evaluation respectively.

\textbf{Case:} $e = \texttt{if\_}\ (\texttt{boolVal true})\ e_1\ e_2$

As with before, we begin by expanding \texttt{typeof}:

\begin{lstlisting}
  typeof (if_ (boolVal true) $e_1$ $e_2$)
    = $\langle\textsf{definition of \texttt{typeof}}\rangle$
  case (typeof (boolVal true), typeof $e_1$, typeof $e_2$)
    of (Just Bool, Just $\tau_1$, Just $\tau_2$) ->
         if_ $\tau_1 = \tau_2$ then Just $\tau_1$ else Nothing
      ...
\end{lstlisting}

We are once again stuck. Unlike before, we have no assumptions about whether
$e_1$ or $e_2$ are steppable, so we cannot cite the inductive hypothesis. By
the assumption that $e$ is well-typed, we can assume that $e_1$ and $e_2$ have
the same type, namely that $\texttt{typeof} e_1 = \texttt{typeof} e_2 =
\texttt{Just}\ \tau$ for some $\tau$. Then:

\begin{lstlisting}
  case (typeof (boolVal true), typeof $e_1$, typeof $e_2$)
    of (Just Bool, Just $\tau_1$, Just $\tau_2$) ->
         if_ $\tau_1 = \tau_2$ then Just $\tau_1$ else Nothing
      ...
    = $\langle\textsf{assumption}\rangle$
  if $\tau = \tau$ then Just $\tau$ else Nothing
    = $\langle\textsf{evaluation step}\rangle$
  Just $\tau$
    = $\langle\textsf{assumption}\rangle$
  typeof $e_1$
\end{lstlisting}

Here, we needed to make a human judgment of which of $e_1$ or $e_2$ to evaluate
to.

\subsection{Reflection}

\section{Future Work}

\bibliographystyle{acm}
\bibliography{refs}

\end{document}
%%
