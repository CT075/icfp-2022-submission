%%%% Generic manuscript mode, required for submission
%%%% and peer review
\documentclass[manuscript,screen,review,sigplan]{acmart}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{XXX}
\copyrightyear{2022}
\acmYear{2022}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[ICFP '22]{International Conference on Functional Programming}{Sept 11--16,
  2022}{Ljubljana, Slovenia}
%
%  Uncomment \acmBooktitle if th title of the proceedings is different
%  from ``Proceedings of ...''!
%
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
% June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{listings}
\usepackage{amsthm}

\lstset{
  basicstyle=\small\ttfamily,
  mathescape
}

\newtheorem{theorem}{Theorem}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Equationally Correct Semantics (Extended Abstract)}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Cameron Wong}
\affiliation{%
  \institution{Jane Street/Harvard University}
  \country{USA}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Wong}

\newcommand{\N}{\mathbb{N}}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10002990</concept_id>
<concept_desc>Theory of computation~Logic and verification</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Logic and verification}
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{dependent types, soundness, language semantics}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

%When developing a new programming language, the most important foundational
%consideration is ensuring that it is \emph{type safe}. Without this crucial
%property, it is difficult to reason abstractly about programs written in such
%a language, often requiring extra specification, or whole-program reasoning to
%ensure that a seemingly type-correct program behaves as desired. Despite this
%importance, the process of producing a soundness proof is rarely interesting in
%and of itself, with the proof(s) frequently reduced to a sketch stating only
%what to induct on.

%It can be far more illustrative when a soundness proof \emph{fails}, as this
%can highlight inherent problems with the core language semantics and suggest
%way those problems can be fixed. But how can this be, when the finished proofs
%are so simple as to be left as exercises to the reader?

%As these proofs are so simple, a natural question is whether these proofs can
%be automatically generated. While there is a wealth of recent work on
%\emph{implementing} programming languages in an automatically correct way
%(Rouvoet \cite{rouvoet:2021}, Pardo et al \cite{pardoetal:2018}, among many
%others), we were unable to find any research on automatically ensuring that the
%language semantics \emph{themselves} are sound.

We developed a new technique for systemically deriving type-safe
small-step operational semantics automatically satisfying progress and
preservation with respect to a typing algorithm. All proofs and
derivations have been mechanised in the Agda proof assistant.

Our technique is an adaptation of the one pioneered by Bahr and Hutton
\cite{bahr:2015} for computing compilers. Following the example of
Pickard and Hutton \cite{pickard:2021}, we choose a dependently-typed
setting to avoid troublesome partiality issues. We will first describe
how type soundness can be phrased as an equation, then use that equation
to derive a small-step operational semantics for a simple expression
language.

\section{Type Safety as an Equation}

We seek to define a runtime semantics for a language, which we quantify as
the function \texttt{step}.  Our first order of business is to phrase our
correctness condition as an equation relating \texttt{step} to our other
desired quantities, namely, type soundness.

The classic statement of type soundness is the twin theorems of
progress and preservation \cite{harper:pfpl}. Colloquially, progress states
that ``well-typed programs do not get stuck'', and preservation states that
``a program has the same type after each evaluation step''. The latter seems
like a promising equation candidate, as it is a statement \emph{equating} two
things --- namely, the type of an expression before and after each step.

We specify the target language by converting its typing judgment $\Gamma
\vdash e : \tau$ into an Agda function

\begin{equation*}
  \texttt{typeof} : \texttt{Exp} \rightarrow \texttt{Maybe Type}
\end{equation*}

with the property $\texttt{typeof}\ e = \tau$ iff $\emptyset \vdash e : \tau$.

Next, consider syntactic values, which cannot be stepped. Typically, this is
expressed by having the \texttt{step} function return a partial value such as a
\texttt{Maybe}. In an equation, however, we will have to branch on the result,
which becomes unwieldy. Instead, we parameterize the \texttt{Exp} datatype by
whether it can be stepped.

\begin{lstlisting}
  data Steppable : Set where
    Value: Steppable
    Steps: Steppable

  data Exp : Steppable $\rightarrow$ Set where
    ...

  step : ($e:$ Exp Steps) $\rightarrow \exists S . \texttt{Exp}\ S$
\end{lstlisting}

Notice that \texttt{step} now returns an existential \texttt{Exp }$S$, as we
cannot know whether the result can be evaluated further.

There is a further issue of attempting to step ill-typed programs. In the
mechanisation, this is addressed by further amending \texttt{step} to also take
a proof that its argument is well-typed. As Agda enforces that functions are
total, such a function actually serves as a proof of the progress theorem.
This obscures the process, however, so we will elide it from the type of
\texttt{step} and instead merely include it as an assumption.

All the pieces are
in place, then, to relate progress (\texttt{step}) to the typing judgment
(\texttt{typeof}) via the \emph{preservation equation}:

\begin{equation}\label{eq:preservation}
  \texttt{typeof}\ e = \texttt{typeof}\ (\texttt{step e})
\end{equation}

where $e : \texttt{Exp CanStep}$.

\section{The Derivation}

\subsection{Target Language}

Our target language for this demonstration is the simple, typed expression
language presented in Figure \ref{lang}\footnote{We do not use the usual
dependently-typed technique of parameterizing \texttt{Exp} with its type, as it
would trivialize the \texttt{typeof} function}.

\begin{figure}[htbp]
  \begin{lstlisting}[basicstyle=\small\ttfamily]
  data Exp : Steppable $\rightarrow$ Set where
    boolVal : Bool $\rightarrow$ Exp Value
    intVal : $\N \rightarrow$ Exp Value
    add : Exp $S \rightarrow$ Exp Steps
    if_ : Exp $S_n \rightarrow$ Exp $S_1 \rightarrow$ Exp $S_2 \rightarrow$ Exp Steps
    
  data $\vdash$_:_ : Exp $S$ $\rightarrow$ Type $\rightarrow$ Set where
    typ-bool : $\vdash$(boolVal b):Bool
    typ-nat : $\vdash$(intVal i):$\N$
    typ-add : $\vdash e_1:\N \rightarrow \vdash e_2:\N \rightarrow \vdash (\texttt{add}\ e_1\ e_2):\N$
    typ-if : $\vdash e:\texttt{Bool} \rightarrow \vdash e_1:\tau \rightarrow \vdash e_2:\tau \rightarrow \vdash (\texttt{if}\ e\ e_1\ e_2):\tau$
  \end{lstlisting}
  \caption{Target language and typing rules}
  \label{lang}
\end{figure}

\begin{figure}[htbp]
  \begin{lstlisting}[basicstyle=\small\ttfamily]
  typeof (add $e_1$ $e_2$) =
    case (typeof $e_1$, typeof $e_2$)
      of (Just $\N$, Just $\N$) -> Just $\N$
       | _ -> Nothing
  typeof (if_ $e$ $e_1$ $e_2$) =
    case (typeof $e$, typeof $e_1$, typeof $e_2$)
      of (Just Bool, Just $\tau_1$, Just $\tau_2$) ->
           if $\tau_1 = \tau_2$
             then Just $\tau_1$
             else Nothing
       | _ -> Nothing
  \end{lstlisting}
  \caption{Definition of \texttt{typeof}, selected cases
    \protect\footnotemark}\label{def:typeof}
\end{figure}

\footnotetext{The actual
implementation in Agda is somewhat more complex, and is simplified for
presentation. Agda does not support Haskell-style \texttt{case} expressions,
nor can it, in general, decide equality or inequality of \texttt{Set}s.
Instead, we use the usual \texttt{fold} operator over the \texttt{Maybe}
type and use a regular Agda variant to represent $\N$ and \texttt{Bool}.}

Our goal is to define the function \texttt{step}
satisfying equation \ref{eq:preservation}. As per Bahr and Hutton
\cite{bahr:2015}, we will proceed by structural induction on $e$, evaluating
the left hand side of equation \ref{eq:preservation} and seek to transform it
into an expression of the form $\texttt{typeof}\ c$, then take $\texttt{step e}
= c$ as a definition for that case of \texttt{step}.

\subsection{Semantics Calculation}

Let $\vdash e : \tau$. For brevity, we show only two representative cases.

\hfill

\textbf{Case:} $e = \texttt{add}\ e_1\ e_2$, where $e_1 : \texttt{Exp CanStep}$

\hfill

We begin by applying the definition of \texttt{typeof} from Figure \ref{def:typeof}:

\begin{lstlisting}
  typeof (add $e_1$ $e_2$)
    = $\langle\textsf{definition of \texttt{typeof}}\rangle$
  case (typeof $e_1$, typeof $e_2$) ...
\end{lstlisting}

We are immediately stuck, as we cannot expand $\texttt{typeof}\ e_1$ any
further. To proceed, we have no choice but to cite the inductive hypothesis:

\begin{lstlisting}
  case (typeof $e_1$, typeof $e_2$) ...
    = $\langle\textsf{inductive hypothesis on \texttt{typeof} }e_1\rangle$
  case (typeof (step $e_1$), typeof $e_2$) ...
\end{lstlisting}

We finally apply the definition of \texttt{typeof} in reverse:

\begin{lstlisting}
  case (typeof (step $e_1$), typeof $e_2$) ...
    = $\langle\textsf{definition of \texttt{typeof}}\rangle$
  typeof (add (step $e_1$) $e_2$)
\end{lstlisting}

This is now of the form $\texttt{typeof} (\texttt{add}\ e_1\ e_2) = \texttt{typeof}\ c$,
namely, $c = \texttt{add}\ (\texttt{step}\ e_1)\ e_2$. We wrap up by defining
\texttt{step} for this case:

\begin{lstlisting}
  step (add $e_1$ $e_2$) = add (step $e_1$) $e_2$
\end{lstlisting}

We note that this rule specifies ``left-first'' evaluation semantics. In fact,
if both $e_1$ and $e_2$ can be stepped, we have the choice of invoking the
inductive hypothesis on $e_1$, $e_2$ or both, corresponding to left-first,
right-first or parallel evaluation respectively.

\hfill

\textbf{Case:} $e = \texttt{if\_}\ (\texttt{boolVal true})\ e_1\ e_2$

\hfill

As with before, we begin by expanding \texttt{typeof}:

\begin{lstlisting}
  typeof (if_ (boolVal true) $e_1$ $e_2$)
    = $\langle\textsf{definition of \texttt{typeof}}\rangle$
  case ...
    of (Just Bool, Just $\tau_1$, Just $\tau_2$) ->
         if_ $\tau_1 = \tau_2$
           then Just $\tau_1$
           else Nothing
      ...
\end{lstlisting}

We are once again stuck. Unlike before, we have made no assumptions about
whether $e_1$ or $e_2$ are steppable, so we cannot cite the inductive
hypothesis.

By inversion on the assumption $\vdash e : \tau$, we
can conclude that $\vdash e_1 : \tau$ and $\vdash e_2: \tau$, and thus
$\texttt{typeof} e_1 = \texttt{typeof} e_2 = \tau$.

Then:

\begin{lstlisting}
  case ...
    of (Just Bool, Just $\tau_1$, Just $\tau_2$) ->
         if_ $\tau_1 = \tau_2$
           then Just $\tau_1$
           else Nothing
      ...
    = $\langle\textsf{assumption}\rangle$
  if $\tau = \tau$ then Just $\tau$ else Nothing
    = $\langle\textsf{evaluation step}\rangle$
  Just $\tau$
    = $\langle\textsf{assumption}\rangle$
  typeof $e_1$
\end{lstlisting}

Here, we needed to make a human judgment of which of $e_1$ or $e_2$ to evaluate
to.

\subsection{Implementation}

The example language semantics, along with their proofs of correctness, have
been fully mechanised in Agda, available at \texttt{https://github.com/CT075/calculated-semantics}.
This includes the unsimplified \texttt{step} fully witnessing progress and a
proof that the \texttt{typeof} function respects the static typing rules.

\section{Reflection and Future Work}

In summary, we have seen that elementary, equational reasoning can be used to
discover an operational semantics for a type system. As with Bahr and Hutton
\cite{bahr:2015}, our proof of soundness falls out of the derivation process.

An unsatisfying part of the derivation is that, ultimately, it requires a human
to make decisions. For example, choosing which branch of the \texttt{if\_}
variant corresponds to \texttt{true}. This has consequences on evaluation
order, as previously noted, but also on correctness. Consider that, as
presented, there is nothing associating the \texttt{add} variant with the $(+)$
operator on naturals beyond our human intuition, which presents an obstacle to
fully automating this process. We hope that the addition of a further language
specification, such as a denotational semantics, may help resolve this.

A logical next step would be to apply this technique to a language with a more
sophisticated typing algorithm. As a first step in this direction, we hope to
derive a semantics for System $F_{\omega}$, the higher-kinded polymorphic
lambda calculus.

\section*{Acknowledgements}

Thanks to Dr. Antal Spector-Zabusky, my friend and confidant of two years at
Jane Street, for presentation advice and for convincing me to submit this work
in the first place. Thanks also to Dr. Jonathan Aldrich, for the early technical
advice necessary to get this project off the ground.

\bibliographystyle{acm}
\bibliography{refs}

\end{document}
%%
